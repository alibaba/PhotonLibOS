--- a/nptl/allocatestack.c
+++ b/nptl/allocatestack.c
@@ -210,7 +210,7 @@ advise_stack_range (void *mem, size_t size, uintptr_t pd, size_t guardsize)
    new stack or reusing a cached stack of sufficient size.
    ATTR must be non-NULL and point to a valid pthread_attr.
    PDP must be non-NULL.  */
-static int
+int
 allocate_stack (const struct pthread_attr *attr, struct pthread **pdp,
                void **stack, size_t *stacksize)
 {
@@ -403,6 +403,18 @@ allocate_stack (const struct pthread_attr *attr, struct pthread **pdp,
                }
            }

+  /* Initialize the TCB.  All initializations with zero should be
+     performed in 'get_cached_stack'.  This way we avoid doing this if
+     the stack freshly allocated with 'mmap'.  */
+
+#if TLS_TCB_AT_TP
+    /* Reference to the TCB itself.  */
+    pd->header.self = pd;
+
+    /* Self-reference for TLS.  */
+    pd->header.tcb = pd;
+#endif
+
          /* Remember the stack-related values.  */
          pd->stackblock = mem;
          pd->stackblock_size = size;
diff --git a/nptl/pthread_create.c b/nptl/pthread_create.c
index 1d3665d5..6ee79035 100644
--- a/nptl/pthread_create.c
+++ b/nptl/pthread_create.c
@@ -665,18 +665,6 @@ __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
     }


-  /* Initialize the TCB.  All initializations with zero should be
-     performed in 'get_cached_stack'.  This way we avoid doing this if
-     the stack freshly allocated with 'mmap'.  */
-
-#if TLS_TCB_AT_TP
-  /* Reference to the TCB itself.  */
-  pd->header.self = pd;
-
-  /* Self-reference for TLS.  */
-  pd->header.tcb = pd;
-#endif
-
   /* Store the address of the start routine and the parameter.  Since
      we do not start the function directly the stillborn thread will
      get the information from its thread descriptor.  */
